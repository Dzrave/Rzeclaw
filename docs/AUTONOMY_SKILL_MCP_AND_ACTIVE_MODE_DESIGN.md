# 自主性、Skill/MCP 与主动模式（Heartbeat / Live Canvas）设计

本文档基于「不预先做完所有场景，而让智能体具备 Skill/MCP 能力并自主规划、选工具、高效执行、自我附加能力」的需求，做**排查结论**与**下一步设计**整理。**仅做排查与设计，暂不实现。**

---

## 一、当前实现排查结论

| 能力 / 概念 | 当前是否具备 | 说明 |
|-------------|--------------|------|
| **Skill / 技能插件** | ❌ 无 | 工具为静态 `CORE_TOOLS`（bash, read, write, edit, process），无运行时加载技能、无插件目录或注册机制。README 仅将「引入技能/插件机制（类似 OpenClaw skills）」列为后续方向。 |
| **MCP（Model Context Protocol）** | ❌ 无 | 无 MCP 客户端、无连接外部 MCP Server、无将「远端 Tools/Resources」纳入 Agent 工具集的能力。 |
| **Heartbeat（主动模式）** | ❌ 无 | 仅「用户发消息 → Gateway/CLI → runAgentLoop」的**被动响应**；无定时唤醒、无「无用户输入时自主检查与执行」的循环。 |
| **Live Canvas（实时画布）** | ❌ 无 | 无共享的、实时可见的「规划/步骤/产物」状态层；无多端同步的「画布」或等价结构（README 明确不包含 Browser/Canvas/Nodes）。 |
| **动态工具发现与注册** | ❌ 无 | 工具列表在构建时写死，Agent 无法在运行时发现或加载新工具、脚本或 MCP 暴露的能力。 |

**结论**：当前 Rzeclaw 是**纯被动、固定工具集**的最小核心；要实现「自主规划、选最佳工具与执行方式、并自我附加能力」，需要新增 **Skill/MCP**、以及按需引入 **Heartbeat** 与 **Live Canvas** 的设计与实现。

---

## 二、需求与目标整理

- **不预先做完所有应用场景**：功能通过「可扩展能力」在需要时由智能体或用户动态获得，而非全部在开发期写死。
- **Skill / MCP 能力**：智能体能够  
  - **发现**：发现可用技能或 MCP 暴露的工具/资源；  
  - **选择**：在规划时选择最合适、最科学的工具与实现方式；  
  - **执行**：以统一方式调用这些能力；  
  - **自我附加**：通过脚本或配置在合理边界内「为自己增加」新能力（如运行某脚本即注册为新工具）。
- **自主性**：在「有明确边界与安全策略」的前提下，智能体可以主动规划、分解任务、选工具、执行并反思，而不是仅对单条用户消息做一次反应。
- **Heartbeat（主动模式）**：在**无用户消息**时也能周期或事件驱动地「醒来」：检查待办、检查清单、执行约定任务或汇报，从而提升主动性。
- **Live Canvas（实时画布）**：提供**共享、可观测**的「当前目标 / 计划 / 步骤 / 产物」状态，便于人与智能体对齐、调试与协作，并为 Heartbeat/多步任务提供可写可读的「工作区」。

---

## 三、是否「需要」Heartbeat 与 Live Canvas（设计结论）

### 3.1 Heartbeat（主动模式）

- **与自主性的关系**：自主性主要体现在「规划、选工具、执行策略」上，可在单次会话内完成；**Heartbeat 解决的是「无人发消息时是否仍会动」**，属于**主动性/持续性**维度。
- **何时需要**：  
  - 需要**周期任务**（如定时检查、定时汇报、定时拉取）时，Heartbeat 或等价「定时唤醒」有必要。  
  - 仅需「用户发一句话，智能体规划并执行完再回复」时，**不必须** Heartbeat；现有「用户 → Agent 循环」即可。
- **建议**：  
  - **若希望智能体「在无人说话时也能按节奏做事」**：建议在架构上**预留 Heartbeat**（定时器 + 唤醒入口 + 策略：读清单/记忆/待办 → 决策是否执行 → 写回结果）。  
  - 实现上可**分阶段**：先定义「唤醒 → 检查 → 可选执行」的接口与配置（如 `heartbeat.intervalMinutes`、`heartbeat.checkListPath`），再实现具体策略（如读 `HEARTBEAT.md` 或 workspace 内待办文件）。

### 3.2 Live Canvas（实时画布）

- **与自主性的关系**：Live Canvas 不直接提供「更自主的决策」，而是提供**共享状态与可观测性**，使「规划、步骤、中间产物」对人可见、可纠偏，并可为 Heartbeat/多步任务提供「当前在做什么、做到哪一步」的持久化视图。
- **何时需要**：  
  - 需要**长时任务、多步规划、人机协同纠偏**时，画布（或等价的共享状态/文档）很有价值。  
  - 仅需单次请求–响应或短会话时，**不必须** Live Canvas；可用现有会话消息 + 可选「规划步骤注入」代替。
- **建议**：  
  - **若希望「规划与执行过程对用户实时可见、可编辑」**：建议在架构上**预留 Live Canvas**：即一层**与会话解耦的、可被 Agent 与前端读写的共享状态**（如当前目标、步骤列表、步骤状态、关键产物链接）。  
  - 最小形态可以是：**结构化文档或 JSON 文件**（如 `workspace/.rzeclaw/canvas/current_plan.json`）+ **Gateway 的「画布读取/推送」接口**，前端或 CLI 可订阅/轮询；不必先做复杂 UI，先做「状态层」即可。

### 3.3 小结

| 能力 | 是否「必须」才能满足你的需求 | 建议 |
|------|------------------------------|------|
| **Skill / MCP** | **是**（否则无法动态选工具、自我附加能力） | 作为下一阶段核心能力做设计与实现。 |
| **Heartbeat** | **视场景**（仅要「单次请求内自主规划执行」则非必须） | 建议**预留设计**：配置项 + 唤醒入口 + 检查策略接口；实现可后置。 |
| **Live Canvas** | **视场景**（仅要「单次会话内可观测」则可用现有会话） | 建议**预留设计**：共享状态/画布数据结构 + 读写 API；最小实现可为「文件 + Gateway 读/推」。 |

---

## 四、下一步开发内容设计（仅设计，不实现）

以下按「依赖与优先级」整理为可拆工单的**设计块**，便于后续排期与实现。

### 4.1 能力层：Skill 与 MCP

**目标**：Agent 在运行时除固定 `CORE_TOOLS` 外，还能使用「技能」或「MCP 暴露的工具」，并能按需发现与选择。

- **Skill 抽象**  
  - 定义「技能」为：**名称 + 描述 + 参数 schema + 执行入口**（如本地脚本、HTTP 回调、或内置函数）。  
  - 技能来源：**本地配置/目录**（如 `workspace/.rzeclaw/skills/*.json` + 可执行脚本）、或** MCP Server**。  
  - Agent 每轮或每会话可拿到「CORE_TOOLS + 已加载 Skills + 当前可用 MCP 工具」的**合并工具列表**，再规划与调用。

- **MCP 客户端**  
  - 实现**轻量 MCP 客户端**：连接一个或多个 MCP Server（配置或发现），获取其暴露的 **Tools**（及可选 Resources/Prompts）。  
  - 将 MCP Tools 映射为 Agent 可调用的「工具」形态（名称、描述、参数），在 runAgentLoop 中与 CORE_TOOLS、本地 Skills **合并**后传给模型。  
  - 调用时：由 Gateway/Agent 将「工具调用」路由到 MCP Client，由 MCP Client 请求对应 MCP Server 执行，结果再回填到 Agent 对话。

- **自主性与安全**  
  - **发现**：通过配置显式声明可用的 MCP Server 与本地 Skill 目录，避免任意发现带来的风险。  
  - **执行**：Skill 执行可限定在 workspace 或指定目录；MCP 工具执行由 MCP Server 侧控制，Rzeclaw 侧仅做转发与结果回传。  
  - **自我附加**：可设计「用户确认后，将某脚本或某 MCP 工具注册为持久 Skill」的流程，避免全自动写盘带来的安全与可审计性问题。

**可拆工单（示意）**：  
- WO-6xx：Skill 抽象与本地 Skill 加载（配置/目录 + 注册到 Agent）。  
- WO-6xx：MCP 客户端（连接、拉取 Tools、调用 Tool、结果回传）。  
- WO-6xx：Agent 工具合并（CORE + Skills + MCP）与调用路由。  
- WO-6xx：安全与审计（Skill 来源白名单、执行边界、可选「用户确认后持久化」）。

### 4.2 主动模式：Heartbeat（预留设计）

**目标**：在无用户消息时，支持按周期或事件「唤醒」Agent 做检查与可选执行。

- **入口**  
  - **定时**：如 `heartbeat.intervalMinutes`（0 表示关闭），由 Gateway 或独立进程按间隔触发「一次 Heartbeat 循环」。  
  - **事件**（可选）：如「某文件变更」「某 API 回调」触发一次唤醒，与定时二选一或并存。

- **Heartbeat 循环（单次）**  
  1. **Orient**：加载身份/策略（如 `AGENTS.md`、`HEARTBEAT.md` 或配置中的 checklist 路径）。  
  2. **Check**：读取「待办/清单/记忆」或调用轻量逻辑（如检查某文件、某 API 状态）；可选在此步用 LLM 判断「是否有需要执行的事项」。  
  3. **Act**：若有待办且策略允许，可调用 runAgentLoop（或仅工具）执行一步或多步，输入可来自「清单中的一条」或模型生成的计划。  
  4. **Record**：将会话摘要/结果写回记忆或指定文件，便于下一轮或用户查看。

- **与现有架构的关系**  
  - Heartbeat 不替代「用户发消息 → chat」路径，而是**额外**的入口；可复用现有 runAgentLoop、记忆、工具层。  
  - 建议**先只做「唤醒入口 + 配置 + 单次 Check/Act 接口」**，具体策略（读哪些文件、是否用 LLM）可后续迭代。

**可拆工单（示意）**：  
- WO-6xx：Heartbeat 配置项与唤醒入口（定时器 + 单次 heartbeat tick）。  
- WO-6xx：Heartbeat 策略接口（Orient/Check/Act/Record 的占位或最小实现，如读 `HEARTBEAT.md` 并执行一条）。

### 4.3 可观测与协作：Live Canvas（预留设计）

**目标**：提供「当前目标 / 计划 / 步骤 / 产物」的共享状态，供 Agent 与用户（或前端）读写，支持实时可观测与人机协同。

- **最小形态**  
  - **状态结构**：如 `CurrentPlan { goal?, steps: Step[], currentStepIndex?, artifacts?: { name, pathOrRef }[] }`，可持久化为 `workspace/.rzeclaw/canvas/current.json` 或等价。  
  - **读写**：  
    - Agent 在规划/执行中可**写**：更新 goal、steps、currentStepIndex、artifacts。  
    - Gateway 提供 **canvas.get** / **canvas.update**（或 **canvas.subscribe** 推送），前端或 CLI 可读/订阅。  
  - **与 runAgentLoop 的衔接**：在「规划模式」或「多步执行」中，每步结束后将「已完成步骤、当前步骤、产出」写回 Canvas，便于 Heartbeat 或下一轮读取。

- **进阶（可选）**  
  - 多画布（按 session 或 task 分）、版本/历史、权限（仅当前用户/workspace）。  
  - 前端「画布 UI」可后做，先保证**状态层 + API** 即可。

**可拆工单（示意）**：  
- WO-6xx：Canvas 状态结构与持久化（文件或键值存储）。  
- WO-6xx：Gateway canvas.get / canvas.update；可选 canvas.subscribe（如 WebSocket 推送）。  
- WO-6xx：Agent 侧在规划/多步执行中写回 Canvas（与现有规划步骤回填可共用或扩展）。

### 4.4 与「自主性」的闭环

- **单次会话内自主**：已有「目标锚定 + 轻量规划 + 执行后反思 + 错误恢复」；配合 **Skill/MCP** 后，Agent 可在**同一次 runAgentLoop** 内使用更多工具、选更优路径，形成「规划 → 选工具（含 Skill/MCP）→ 执行 → 反思」的闭环。  
- **跨会话/持续自主**：依赖 **Heartbeat** 与**记忆/待办**：Heartbeat 定期唤醒 → 读待办与记忆 → 决策是否执行 → 执行并写回，形成持续主动性。  
- **可观测与可控**：**Live Canvas** 把「当前在做什么、做到哪」暴露给人，便于纠偏与信任；同时可为 Heartbeat 提供「上次未完成计划」的恢复点。

---

## 五、建议的实现顺序（仅顺序，不实现）

1. **Skill 抽象 + 本地 Skill 加载**（使「新能力」可被加载并参与规划与执行）。  
2. **MCP 客户端 + 工具合并与路由**（使 Agent 能使用外部 MCP 能力，与 CORE_TOOLS 统一）。  
3. **Canvas 状态层 + Gateway 读/写 API**（为规划/多步/Heartbeat 提供共享状态）。  
4. **Agent 写回 Canvas**（规划或执行中更新 current plan / steps / artifacts）。  
5. **Heartbeat 入口 + 配置 + 最小策略**（定时唤醒 + Orient/Check/Act/Record 占位或最小实现）。  

以上顺序可在后续写成具体 Phase 6（或新阶段）工单，再按依赖实现。本文档仅做排查与设计，**不包含具体实现**。

---

## 六、更主动、更智能的机制：是否一定要 Heartbeat？（补充设计）

本节针对「在用户未发命令时就做计划与探索、在用户发令或长时间未用时根据任务/需求推断（含用户未意识到的需求）并主动提议、由用户决策」这一**本质诉求**，说明：**Heartbeat 只是实现「何时触发」的一种方式**；更智能的主动能力可以不必依赖「定时心跳」，也可以与 Heartbeat 组合成更先进的形态。

### 6.1 本质诉求归纳

- **无命令时**：智能体已在进行**计划制定、方案寻找与探索、甚至讨论**（与谁讨论可设计：与自身、与记忆、与外部知识）。
- **有命令时 / 长时间未用后**：根据**任务体系或用户需求**，  
  - **推断**用户的需求（含用户**未曾想到**的需求）；  
  - **主动提出**建议、选项或讨论；  
  - 把**决策权**交给用户（提议而非擅自执行）。

即：要的是**主动性 + 需求推断 + 提议式交互**，而不是「只有定时醒来」这一种形态。

### 6.2 Heartbeat 在其中的角色

- **Heartbeat** 解决的是「**何时**让智能体跑起来」：**时间维度**上的触发（例如每 N 分钟唤醒一次）。
- 它**不决定**：  
  - 醒来后**看什么**（任务体系、记忆、上下文）、  
  - **怎么推理**（需求推断、机会发现、提议生成）、  
  - **输出什么**（建议列表、讨论摘要、待决策项）。

因此：  
- **实现「主动提议」不必然依赖 Heartbeat**；  
- Heartbeat 只是**多种触发方式之一**（时间触发）。  
- 更智能的机制 = **更合适的触发方式** + **需求/任务推断** + **提议与决策分离**。

### 6.3 比「纯定时 Heartbeat」更智能的机制（设计级）

下面几类机制可以**替代或补充** Heartbeat，实现更主动、更智能的行为。

| 机制 | 含义 | 与 Heartbeat 的关系 |
|------|------|---------------------|
| **事件驱动触发** | 在**上下文变化**时触发一次「主动推理/提议」，而不是仅按时间。例如：某文件变更、某目录有新提交、日历/待办有新项、或「用户超过 N 天未使用」被记为事件。 | 可**替代**纯定时：用「事件发生时」代替「每 N 分钟」；也可与 Heartbeat **并存**（事件 + 定时双触发）。 |
| **任务/目标体系 + 需求推断** | 维护**结构化任务或目标**（如待办树、目标列表、项目阶段），并在每次触发时：  
  - 用 LLM 或规则对「当前任务、记忆、最近行为」做**需求推断**；  
  - 识别**缺口、风险、未提及但相关的需求**；  
  - 生成**提议**（下一步建议、可选方案、需用户确认的决策）。 | **不依赖** Heartbeat；谁**触发**（定时/事件/用户打开界面）都可以用同一套「任务 + 推断 + 提议」逻辑。 |
| **前瞻/推测式推理（Anticipatory）** | 在**空闲或低负载**时运行轻量推理：根据历史行为、任务体系、当前上下文，**预测**用户接下来可能需要的帮助或风险，并预先准备好**方案摘要或讨论草稿**；待用户出现时直接呈现「我已根据…做了初步分析，建议…请决策」。 | 可由 **Heartbeat 或事件** 触发，但**智能**在「预测 + 预生成」；也可由「用户打开会话」触发一次「回顾 + 提议」（无需定时）。 |
| **推送式提议（Proactive Push）** | 智能体在满足条件时**主动推送**一条「建议/待决策项」到前端、邮件或通知，而不是等用户来问。条件可以是：定时、事件、或「推断出高置信度需求」时。 | 触发层可用 Heartbeat（定时检查是否要推送）、也可用事件或「推断 pipeline 完成」；**推送**是输出形态，**推断**是核心。 |
| **持续轻量后台（Watcher）** | 常驻轻量进程：**不**定时跑完整 Agent，而是**监听**文件/API/队列等；仅在检测到「可能需主动介入」时再唤醒**一次**推理或提议。 | 用**事件**代替**固定周期**，往往更省资源、更贴时机；可视为「事件驱动的 Heartbeat」。 |

### 6.4 是否一定要 Heartbeat？更先进的形态是什么？

- **不一定要 Heartbeat**。  
  - 若「主动提议」的触发完全由**事件**（如文件变更、用户打开应用、长时间未用后的首次访问）或**用户主动请求**（如「根据我当前任务给点建议」）完成，则**不需要**定时 Heartbeat。  
  - 此时：**事件/请求 → 读任务与记忆 → 需求推断 → 生成提议 → 呈现给用户决策**，即可实现「更主动」的体验。

- **更智能、更先进的形态**可以是：  
  1. **统一「主动推理」管道**：输入 = 当前任务体系 + 记忆 + 上下文 + 触发原因（事件/定时/用户打开）；输出 = 建议列表、待决策项、讨论摘要。  
  2. **多种触发源**：  
     - **时间**：Heartbeat（定时）；  
     - **事件**：文件/日历/待办/「长时间未用」；  
     - **显式**：用户点击「给我建议」或打开会话时自动跑一次。  
  3. **任务/需求层**：维护任务树或目标列表（可来自用户维护或从对话中抽取）；每次主动推理时做**需求推断**（含未言明需求）与**机会/风险识别**。  
  4. **提议与执行分离**：主动输出仅为**提议**；执行（如写文件、发邮件）需用户确认或授权，避免「擅自行动」。

在这种设计下，**Heartbeat 是可选的**：  
- 若希望「即使用户不操作、不打开界面，也定期收到建议或待办提醒」，则保留**定时触发**（Heartbeat）。  
- 若希望「只在有上下文变化或用户出现时再主动」，则用**事件驱动 + 打开时触发**即可，无需 Heartbeat。  
- **更先进**的形态是**两者并存**：定时 + 事件 + 打开时，共用同一套「任务 + 推断 + 提议」逻辑，仅触发源不同。

### 6.5 小结（针对「更主动、更智能」）

| 问题 | 结论 |
|------|------|
| 是否一定要 Heartbeat？ | **否**。主动提议可由事件、用户打开、或「长时间未用后首次访问」触发；Heartbeat 只是**时间维度的触发方式之一**。 |
| 更智能的机制是什么？ | **任务/目标体系 + 需求推断（含未言明需求）+ 提议与决策分离**；**事件驱动**与**前瞻/推测式推理**可显著提升「在无命令时的有用主动」。 |
| 更先进的形态？ | **统一主动推理管道** + **多触发源**（定时 / 事件 / 打开时）+ **任务与记忆** 作为输入；Heartbeat 作为可选触发源之一，与事件、显式请求并列。 |
