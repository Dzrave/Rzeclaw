# 智能助手可操作 IDE / PC 能力设计

本文档探索并设计「让智能助手具备可操作 IDE 与主机」所需的**机制与能力**：优先通过终端/脚本直接操作；对必须依赖图形界面或类人键鼠的操作，设计可选的能力层与边界。**仅设计，不实现。**

---

## 一、目标与范围

### 1.1 目标

- **可操作主机**：助手不仅能读文件、跑命令，还能在用户授权范围内**主动完成**需要与 IDE、系统或第三方软件交互的任务（如打开工程、切换标签、执行构建、操作仅提供 GUI 的软件）。
- **优先终端/脚本**：凡能用命令行、脚本或 API 完成的，一律通过现有 bash/脚本/进程能力完成，不引入额外风险与复杂度。
- **补足 GUI 缺口**：当目标软件**无 CLI、无 API、仅支持图形界面**时，提供可选能力层，使助手能通过「程序化 UI 自动化」或「类人键鼠模拟」完成操作，并在设计上明确边界与安全策略。

### 1.2 范围

- **在控环境**：假定助手运行在用户可控的主机或工作机上（本地或自托管 Gateway），非不可控的远程沙箱。
- **授权先行**：所有超出「当前 workspace 读写的命令与文件」的能力（尤其是键鼠/UI 自动化）均需在配置或策略上显式启用，并建议「可审计、可关闭」。
- **不替代人类**：类人操作层用于「在用户授权下完成明确任务」，不设计为替代用户长期占用前端或执行未授权操作。

### 1.3 多操作系统与操作方式：覆盖与边界

本设计**明确考虑**多种操作系统与多种操作方式，但**不声称**当前机制可「几乎完全处理任何相关操作」；存在已知边界与 best-effort 场景，见下表。

**操作系统维度**：

| 系统 | L1 终端/脚本 | L2 UI 自动化 | L3 键鼠/视觉 | 说明 |
|------|----------------|----------------|----------------|------|
| **Windows** | ✅ 完整（cmd/PowerShell） | ✅ 完整（UIA） | ✅ 可行（系统 API） | 三端均有一致支持，优先实现。 |
| **macOS** | ✅ 完整（bash/zsh） | ✅ 完整（AX） | ✅ 可行（AX 或 CGEvent） | 与 Windows 并列优先。 |
| **Linux (X11)** | ✅ 完整 | ⚠️ 依赖桌面（AT-SPI） | ✅ 可行（XTest 等） | GNOME/KDE 等支持较好。 |
| **Linux (Wayland)** | ✅ 完整 | ⚠️ best-effort | ⚠️ 各 compositor 不一 | 无统一系统级键鼠/可访问性，实现时按 best-effort 处理。 |
| **其它（BSD、无 GUI 服务器、WSL 等）** | ✅ 仅 L1 适用 | ❌ 不适用 | ❌ 不适用 | 仅终端/脚本在范围内；无桌面则无 L2/L3。 |

**操作方式维度**：

| 方式 | 是否在设计中 | 能否「完全处理」 | 说明 |
|------|----------------|------------------|------|
| **CLI / 脚本 / 进程** | ✅ | 仅对「有 CLI 的软件」完全处理 | 无 CLI 的软件无法通过本方式操作。 |
| **LSP / DAP / IDE 协议** | ✅ | 仅对「支持该协议的应用」完全处理 | 协议标准化高，但依赖具体 IDE/语言支持。 |
| **程序化 UI（UIA/AX/AT-SPI）** | ✅ | 否 | 自绘控件、游戏、部分 Electron/未暴露可访问性的应用无法可靠识别；需降级 L3。 |
| **键鼠模拟** | ✅ 可选 | 否 | 分辨率/DPI/多屏/焦点易导致失效；适合兜底而非通用。 |
| **视觉（截图+定位+点击）** | ✅ 可选 | 否 | 延迟与稳定性依赖模型与网络；仅建议在授权窗口内、严格限定。 |

**结论**：

- **多种 OS 与多种操作方式**均在设计考虑之内，并通过 L1/L2/L3 与「语义 > 结构 > 物理」的选型原则覆盖。
- **当前机制不能几乎完全处理任何相关操作**。无法覆盖或仅能 best-effort 的典型情况包括：  
  - 无 CLI、无可访问性、且自绘 UI 的软件（需依赖 L3 视觉或人工）；  
  - Wayland 下部分桌面与 compositor 的 UI 自动化与键鼠；  
  - 强实时或高安全隔离环境（如某些安装程序、UAC 提权窗口）；  
  - 跨机器、远程桌面、虚拟机内的 GUI（除非在目标机侧部署执行端）。
- 设计目标是在**给定 OS 与桌面环境**下，按「优先语义、再结构、最后物理」**尽量**用自动化完成；无法覆盖的部分由「提议 + 人工执行」或明确标注 best-effort 补足。

---

## 二、操作分类：何时用终端，何时需要「类人」操作

| 类型 | 说明 | 示例 | 推荐机制 |
|------|------|------|----------|
| **CLI/脚本可达** | 软件提供命令行、脚本接口或可被脚本驱动 | 构建、测试、git、npm、VS Code CLI (`code`)、部分 IDE 快捷键/命令 | 现有 **bash** / **process**；必要时扩展「执行脚本文件」或「发送键序列到指定进程」 |
| **API/协议可达** | 软件提供本地 API、LSP、DAP 或 WebSocket | LSP 补全、DAP 调试、IDE 扩展 API、Electron 应用 IPC | **MCP / 专用 Skill**；或新工具 **ide_protocol**（调用 LSP/DAP 等） |
| **仅 GUI 可达** | 无 CLI、无开放 API，只能通过点击/输入与界面交互 | 部分安装向导、老旧桌面应用、某些「仅界面」的设置项 | **程序化 UI 自动化**（见下）或 **键鼠模拟**（可选） |

结论：**先做终端与脚本；再按需引入「程序化 UI 自动化」；键鼠模拟仅作为可选补充，用于无法通过 UI 树识别的场景。** 选型原则见第九节的「信息层级」：语义 > 结构 > 物理。

---

## 三、能力分层设计

### 3.1 第一层：终端与脚本（已有 + 小扩展）

**现状**：已有 **bash**（cmd/PowerShell  on Windows）、**read/write/edit**、**process**，足以完成绝大部分「在 workspace 内执行命令、改文件、跑脚本」的需求。

**可扩展点（设计层面）**：

- **脚本执行**：  
  - 支持「执行 workspace 内某脚本文件」并传入参数（可复用 bash：`bash command="node scripts/foo.js --arg=1"`），或提供 **run_script** 工具（path + args），便于助手按步骤执行已写入的脚本。  
- **IDE 命令行**：  
  - 在 usageHint 或 Bootstrap 中明确：VS Code 的 `code`、JetBrains 的 `idea`/`webstorm` 等可在 bash 中调用，用于「打开项目、打开文件、执行 IDE 命令」。  
- **快捷键/命令到前台**：  
  - 若未来引入「发送键序列」，可限定为「发送到当前焦点窗口」或「发送到指定进程的窗口」，用于触发 IDE 内「保存、构建、运行」等已绑定快捷键的操作，仍属「脚本化」思维，而非任意键鼠。

**安全**：保持现有 bash 的 cwd 与白名单/危险命令策略；脚本执行不扩大权限，仅明确语义。

---

### 3.2 第二层：程序化 UI 自动化（推荐优先实现）

**目标**：在不依赖「截图 + 坐标」的前提下，通过**可访问性 API 或 UI 自动化接口**获取窗口/控件树，并执行「点击、输入、选择」等操作，从而操作 IDE 或其它桌面应用。

**机制选型**：

| 平台 | 推荐技术 | 说明 |
|------|----------|------|
| **Windows** | **UI Automation (UIA)** | 系统级，可枚举窗口与控件、读名称/角色/状态、执行 Invoke/SetValue 等；支持 Win32、WPF、UWP、部分 Qt。 |
| **macOS** | **Accessibility API (AX)** | 可获取应用 UI 树、元素属性、执行点击/输入；与系统集成好。 |
| **Linux** | **AT-SPI** | 类似思路，需桌面环境支持（GNOME/KDE 等）；Wayland 下支持因 compositor 而异，实现时可按 best-effort 处理。 |

**能力抽象（工具或 MCP）**：

- **ui_describe**：返回当前焦点窗口或指定应用的「可操作元素树」摘要（窗口标题、控件类型、名称、可执行动作），供模型决定下一步操作。  
- **ui_act**：对指定元素执行动作（如 click、set_value、select）；元素由「窗口 + 层级路径或可访问名称」定位。  
- **ui_focus**：将焦点切换到某窗口或某应用（便于后续键鼠或 ui_act 作用于正确目标）。

**与助手流程的配合**：

- 助手根据用户目标（如「在 IDE 里运行项目」）先尝试 bash（如 `npm run dev`）；若用户明确说「用 IDE 的 Run 按钮」或检测到无 CLI 路径，则调用 ui_describe 获取当前 IDE 窗口结构，再调用 ui_act 执行「点击 Run」等。  
- 结果（成功/失败、可选的控件树摘要）返回给模型，便于多步操作与错误恢复。

**安全与边界**：

- 仅在**显式启用**时加载 UI 自动化能力（如 `config.ideOperation.uiAutomation: true`）。  
- 可限制「仅允许操作特定应用」（如只允许 VS Code、终端、浏览器），避免误操作系统关键界面。  
- 所有 ui_act 建议**可审计**（记录目标窗口/控件与动作），并可选择「敏感操作需确认」。

---

### 3.3 第三层：类人键鼠与视觉（可选补充）

**适用场景**：  
- 控件无法通过 UIA/AX 正确识别（如自绘、游戏、部分 Electron 未暴露可访问性）；  
- 或需要「按坐标点击」「拖拽」「在屏幕某区域识别后再点」等。

**机制选型**：

| 方式 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **键鼠模拟** | 发送系统级 key/click 事件到指定坐标或当前焦点 | 通用、不依赖控件树 | 分辨率/DPI 变化易失效；难以做「语义」级操作；风险高（误点） |
| **图像/视觉** | 截图 → 模型或模板匹配定位目标 → 返回坐标 → 再发送点击 | 可应对自绘 UI、异形控件 | 延迟与稳定性依赖视觉；需严格限制截图范围与用途 |
| **RPA 工具** | 集成现有 RPA 引擎（如 PyAutoGUI、AutoIt、或商业 RPA） | 成熟、可录放 | 依赖与授权复杂；与「助手即兴决策」的配合需设计 |

**设计建议**：

- **键鼠模拟**：若提供，应**严格限定**为「发送到当前焦点窗口」或「发送到由 ui_focus 指定的窗口」，并限制键序列长度与频率，避免被滥用为键盘记录或暴力操作。  
- **视觉点击**：若提供，建议限定为「在助手可控的、用户已授权的窗口内」进行（例如仅限 IDE 窗口区域），并明确「不持久化截图、不用于训练」。  
- **优先级**：第二层（程序化 UI 自动化）能覆盖绝大多数 IDE 与常规桌面软件；第三层仅作为「无法用 UIA/AX 时的兜底」，且建议单独开关与审计。

---

### 3.4 除模拟外的 IDE 操作机制

除通过「模拟用户操作」（L2 控件树点击、L3 键鼠/视觉）与 IDE 交互外，还有多种**非模拟**机制可直接或间接形成对 IDE 的操作，且通常更稳定、可审计、与 IDE 语义一致。在设计与实现时应**优先使用这些机制**，仅在其不可用时再退回到 UI 模拟。

| 机制 | 说明 | 典型能力 | 与模拟的关系 |
|------|------|----------|----------------|
| **IDE 命令行（CLI）** | IDE 提供的可执行命令（如 `code`、`idea`），由助手通过 bash 调用。 | 打开项目/文件、安装扩展、执行命名命令（如 `code --goto file:line`）、在指定文件夹打开新窗口。 | 不涉及 UI，属 L1；优先于任何模拟。 |
| **LSP（Language Server Protocol）** | 与 IDE 共用同一语言服务，以协议客户端身份请求补全、跳转、诊断、重命名等。 | 读符号、跳转定义、查找引用、诊断、代码操作；可与编辑器内状态同构。 | 非模拟；语义层，优先于结构/物理层。 |
| **DAP（Debug Adapter Protocol）** | 与调试器通信，控制断点、单步、变量查看等。 | 下断点、继续/单步、读变量/堆栈；无需「点调试按钮」。 | 非模拟；语义层。 |
| **IDE 扩展 / 内置 API** | 在 IDE 进程内运行的扩展，可调用官方 API 执行命令、打开文件、运行任务、读写编辑器内容。 | 执行命令（如 `workbench.action.tasks.run`）、打开文件、切换编辑器、向集成终端写入内容、读写当前文档。 | 非模拟；由 IDE 自身执行，助手通过「本地服务 ↔ 扩展」与 IDE 通信（如 Gateway 调本地 HTTP，扩展调 Gateway 或反向）。 |
| **工作区文件驱动** | 通过修改工作区内 IDE 可感知的文件（如配置、任务定义），使 IDE 自动响应。 | 修改 `tasks.json`、`launch.json`、设置文件；IDE 重载后生效。结合 CLI「执行任务」或扩展「运行任务」即可触发。 | 非模拟；间接「操作」IDE 行为。 |
| **Headless / 远程 IDE API** | 无 UI 或远程部署的编辑器核心暴露 API（如 Theia、code-server、VS Code Remote Agent）。 | 通过 REST/WebSocket 打开文件、运行任务、执行命令，无需本机 GUI。 | 非模拟；适合无头或远程场景，与「模拟本机 IDE 窗口」互补。 |

**设计建议**：

- 在**能力选择顺序**中，将「IDE CLI → LSP/DAP → IDE 扩展/API → 工作区文件驱动 → Headless API」置于**程序化 UI 自动化与键鼠模拟之前**，与第九节「语义 > 结构 > 物理」一致。  
- **IDE 扩展**：若采用 VS Code，可开发扩展在 IDE 内注册命令或 WebView，由扩展调用本地 Gateway 或 MCP，实现「助手发意图 → 扩展在进程内执行命令」的闭环，无需模拟点击。  
- **LSP/DAP**：可作为独立工具或 MCP 暴露（如 `ide_lsp`、`ide_dap`），与现有「读文件、bash」并列，供模型在语义层完成跳转、诊断、调试等，避免依赖 UI 树或截图。

综上：**除模拟操作 IDE 外**，至少还有 **CLI、LSP、DAP、IDE 扩展/API、工作区文件驱动、Headless/远程 API** 等机制可形成对 IDE 的操作；应优先实现与使用这些机制，再以 L2/L3 作为补充。

---

## 四、与 IDE 的深度结合（可选方向）

若希望助手「像人一样用 IDE」，除上述通用 UI/键鼠层外，可考虑：

- **LSP / DAP**：  
  - 通过 **LSP**（补全、跳转、诊断）与 **DAP**（调试）与编辑器同构数据，使助手能「读符号、下断点、继续执行」，而无需真正「点界面」。可新增工具 **ide_lsp** / **ide_dap** 或通过 MCP 暴露。  
- **IDE 扩展/API**：  
  - 若使用 VS Code，可开发 **VS Code 扩展**，在 IDE 内注册命令或 WebView，由扩展调用 Gateway 或本地服务，实现「助手发起、IDE 执行」的闭环（如打开文件、切换编辑器、运行任务）。  
- **终端在 IDE 内**：  
  - 已有 bash 在 workspace 执行；若终端运行在 IDE 内，可约定「助手生成的命令」通过扩展写入 IDE 集成终端，由用户确认后执行，实现「助手建议命令、人在 IDE 里一键执行」。

以上可作为「第二阶段」或「按需 Phase」细化，与第一～三层能力正交。

---

## 五、安全与策略汇总

| 维度 | 建议 |
|------|------|
| **默认** | 仅启用第一层（终端/脚本）；UI 自动化与键鼠/视觉均默认关闭。 |
| **配置** | 如 `config.ideOperation: { uiAutomation?: boolean; keyMouse?: boolean; visualClick?: boolean; allowedApps?: string[] }`。 |
| **审计** | 所有 UI 动作与键鼠调用写审计日志（目标、动作、时间），便于复盘与关闭。 |
| **范围** | UI 自动化可限制 allowedApps（如 `["Code","cmd","Windows Terminal"]`）；键鼠可限制「仅当前焦点」或「仅指定窗口」。 |
| **确认** | 可选「敏感操作需用户确认」：如 ui_act 修改编辑器内容、键鼠发送到非白名单应用时，先返回「待确认」再由用户批准后执行。 |

---

## 六、实现顺序建议（仅规划不实现）

1. **巩固第一层**：文档化现有 bash/process 对 IDE CLI 的用法；如需可增加 run_script 或等价能力。  
2. **设计并实现第二层**：ui_describe / ui_act / ui_focus 的协议与跨平台抽象；先支持 Windows UIA，再考虑 macOS AX；Linux 可标为 best-effort。  
3. **策略与配置**：ideOperation 配置项、审计、allowedApps（建议支持进程名/路径/窗口类等多匹配）。  
4. **可观测与作用域**：动作结果统一结构（含 state_snapshot/suggested_next）；可选 env_summary 与 workspace–窗口关联的作用域。  
5. **按需第三层**：仅在确有需求时引入键鼠或视觉，并严格限制范围与开关。  
6. **（可选）意图路由与声明式**：意图级动作 + 能力解析、声明式目标状态，可在 L2 稳定后再迭代。

---

## 七、与现有架构的关系

- **工具模型**：新能力以**新工具**（如 ui_describe、ui_act）或 **MCP Server**（暴露 UI 自动化服务）形式接入，与现有 CORE_TOOLS、Skill、MCP 并列。  
- **会话与 workspace**：UI 操作与「当前 workspace」可关联（如仅允许操作「当前 workspace 对应的 IDE 窗口」），便于多项目时不串台。  
- **提议与执行分离**：涉及 UI/键鼠的「执行」可与 Heartbeat/主动提议的「仅提议」策略结合——例如主动提议只产出「建议在 IDE 中执行 Run」，实际点击由用户确认后再执行。

---

## 八、可行性与合理性评估

### 8.1 可行性

| 维度 | 评估 | 说明 |
|------|------|------|
| **L1 终端/脚本** | ✅ 高 | 已有 bash/process，扩展 run_script 与 IDE CLI 文档化无技术风险；仅需约定 cwd、环境与白名单。 |
| **L2 UIA/AX/AT-SPI** | ✅ 中高 | Windows UIA、macOS AX 成熟稳定；Linux 需区分 X11/Wayland，Wayland 下 AT-SPI 支持因桌面而异，需在设计中注明「Linux 为 best-effort」。 |
| **L3 键鼠/视觉** | ⚠️ 中 | 键鼠模拟易实现但脆弱（分辨率/DPI/多显示器）；视觉链路（截图→定位→点击）延迟与稳定性依赖模型与网络，适合作为兜底并严格限定范围。 |
| **LSP/DAP/IDE 扩展** | ✅ 高 | 协议标准明确，MCP 或本地服务封装即可；IDE 扩展需依赖具体产品（如 VS Code）的 API 与上架策略。 |

**结论**：整体可行；实现时建议 L2 先做 Windows，再 macOS；L3 与 Linux 全支持可列为后续 Phase。

### 8.2 合理性

- **「终端优先」**：合理。命令行与脚本具有确定性、可审计、易复现，符合最小权限与可观测性。
- **「UIA 先于键鼠」**：合理。语义化控件树比坐标稳定、可读、易做范围限制（如 allowedApps）。
- **「提议与执行分离」**：与整体架构一致，敏感操作需确认是合理边界。
- **不足**：当前分层按「实现方式」（CLI / UIA / 键鼠）划分，未显式按「信息质量」或「可观测性」建模，导致能力选择与反馈闭环在设计中不够突出；见下节第一性原理重构。

---

## 九、第一性原理视角与设计优化

### 9.1 第一性目标与不变量

- **目标**：将**用户意图**转化为**主机上的可观测状态变化**（文件、进程、UI 状态），在安全、可审计、可恢复的前提下完成。
- **不变量**：  
  - **最小权限**：仅使用完成目标所需的最低层级能力。  
  - **可观测**：每次操作应有明确结果（成功/失败 + 必要时的新状态摘要），便于模型纠偏与重试。  
  - **可归属**：能区分「用户明确指令」「助手提议待确认」「助手已授权执行」，便于审计与策略。

由此可导出：**优先使用语义最强、歧义最低、副作用最可控的通道**；仅当该通道不可用时才降级。

### 9.2 按「信息层级」而非仅「实现方式」分层

建议在保留现有 L1/L2/L3 实现分层的同时，显式引入**信息层级**，用于能力选择与降级策略：

| 信息层级 | 含义 | 对应能力 | 选择原则 |
|----------|------|----------|----------|
| **语义层** | 领域协议与结构化 API（LSP、DAP、IDE 命令、CLI） | LSP/DAP、IDE 扩展、bash 调用已知命令 | 若目标可被语义层表达，则只用语义层。 |
| **结构层** | 可访问的 UI 树（控件、角色、名称、状态） | UIA/AX/AT-SPI（ui_describe / ui_act） | 无语义接口时，用结构层做「有名称的点击/输入」，避免坐标。 |
| **物理层** | 像素、坐标、原始键鼠事件 | 键鼠模拟、视觉定位点击 | 仅当结构层不可用或不可靠时使用；严格限定范围与频率。 |

**优化建议**：在工具或 MCP 的设计中增加「**能力解析器**」逻辑——对同一用户意图（如「运行当前文件」），系统按「语义 → 结构 → 物理」顺序尝试可用通道，而不是由模型任意选择；模型可表达意图，执行层负责选通道与降级。

### 9.3 统一动作模型与能力路由（可选进阶）

- **现状**：bash、ui_*、keymouse 为多套独立工具，模型需自行选择「用哪种」。
- **优化**：引入**意图级动作 + 能力路由**。  
  - 定义一组**意图动作**（如 `run_current_file`、`open_file_in_editor`、`focus_window`），参数为语义化（如 file path、window title）。  
  - **执行层**根据当前环境（已安装 CLI、已连接 LSP/DAP、当前焦点窗口、allowedApps）将意图解析为**具体能力调用序列**（先试 DAP/IDE 命令，再试 bash，再试 ui_act，最后才键鼠），并返回执行结果与使用的通道。  
  - 模型只需产出意图与参数，降低「选错工具」与「重复试错」的概率，同时便于统一做权限与审计。

若实现成本较高，可先保留「多工具」形态，但在 Bootstrap 或 Prompt 中明确**决策顺序**（先 CLI/API，再 UIA，再键鼠），并让 ui_act 等返回「建议下一步」的简短摘要，以减轻模型负担。

### 9.4 可观测性与反馈闭环

- **问题**：若 ui_act 仅返回「成功」或「失败」，模型难以判断界面是否真的进入预期状态（如弹窗是否关闭、标签是否切换），易产生幻觉或无效重试。
- **优化**：  
  - **动作后状态摘要**：ui_act / keymouse 执行后，可选返回「受影响区域」的轻量 ui_describe（如当前焦点窗口的标题与根控件列表），便于模型做「状态是否变化」的简单验证。  
  - **统一结果结构**：所有操作返回 `{ success, channel_used?, state_snapshot?, error?, suggested_next? }`，便于多步编排与日志分析。  
  - **显式失败与重试策略**：定义可重试错误（如「控件暂时不可见」）与不可重试错误（如「应用不在白名单」），在文档或实现中约定模型或执行层的重试上限与回退行为。

### 9.5 能力发现与作用域（Scope）

- **问题**：模型若不知道「当前有哪些窗口」「workspace 对应哪个 IDE 实例」「是否有 LSP」，容易盲目调用 ui_describe 或 bash。
- **优化**：  
  - **能力发现**：提供轻量工具或会话上下文，如 `env_summary`（当前 workspace、已检测到的 LSP/终端、当前焦点窗口/应用名），在会话初始化或 Heartbeat 时更新，供模型规划时使用。  
  - **作用域**：将**操作范围**显式建模为 (workspace, allowed_processes_or_windows, time_bound)。例如「仅允许操作与当前 workspace 关联的 IDE 窗口」——通过「窗口标题或工作目录包含 workspace 路径」等启发式绑定，比仅用进程名更稳定。allowedApps 建议支持「进程名 / 可执行路径 / 窗口类」多种匹配方式，并在文档中说明优先级与安全含义。

### 9.6 声明式意图与幂等（可选）

- **现状**：设计偏「 imperative」（执行点击、执行输入），多步操作易因界面时序或失败而产生中间态不一致。
- **优化方向**：对可表达的「目标状态」做声明式描述，由执行层推导动作序列并尽量幂等。例如：「确保文件 F 已在编辑器打开」→ 先查询当前打开文件列表，若已打开则 focus，否则执行打开；「确保已执行一次 build」→ 检查最近一次构建时间或标记，未满足再执行。可先在 L1（脚本/CLI）和 LSP/DAP 侧做小范围试点（如「打开文件」「运行测试」），再考虑是否扩展到 UI 层。

---

## 十、优化后的设计要点汇总

1. **保留现有 L1/L2/L3 分层**，增加**信息层级**（语义 > 结构 > 物理）与**选择原则**，并在实现或 Prompt 中体现「优先语义、再结构、最后物理」。  
2. **可观测性**：动作结果统一包含 success / state_snapshot / suggested_next；ui_act 后可选返回局部 ui_describe，便于验证与重试。  
3. **能力发现与作用域**：提供 env_summary 类上下文；作用域显式为 (workspace, 允许的进程/窗口, 时间)；allowedApps 支持多匹配方式并与 workspace 关联。  
4. **（可选）意图级动作与能力路由**：模型产出意图+参数，执行层按语义→结构→物理解析为具体工具调用，统一审计与降级。  
5. **（可选）声明式与幂等**：对「打开文件」「运行构建」等可表达目标状态的操作，优先声明式 + 幂等执行，减少无效重复与中间态不一致。

以上优化不改变「仅设计、不实现」的定位，但使后续实现更科学、可扩展、易与蜂群架构（提议与执行分离、审计、多 workspace）对齐。

---

## 十一、操作与命令的进一步优化与扩展方向

在现有设计方案（L1/L2/L3、意图路由、可观测性、声明式等）基础上，以下方向可进一步**优化操作/命令的表达、执行与扩展**，使实现更先进、可维护且与现有代码（如 `ToolDef`、`getMergedTools`、`ToolResult`）自然衔接。

### 11.1 操作组合与工作流（复合操作）

- **现状**：单次工具调用对应单一步骤（一次 bash、一次 ui_act 等），多步依赖模型多次调用与上下文记忆。  
- **优化**：  
  - 支持**复合操作**（compound operation）：一个「操作」由若干子步骤组成（如「先 ui_focus IDE → 再 ui_act 点击 Run → 再等待 2s → 再 ui_describe 检查结果」），可封装为单工具或单意图，由执行层按序执行并汇总结果。  
  - 可选**条件分支**：某步失败或满足某条件时执行备选路径（如「若 bash 返回非零则尝试 ui_act 点击 Run」），减少模型多轮试错。  
- **扩展方式**：新增工具如 `run_workflow`（传入步骤 DAG 或顺序列表 + 可选条件），或由 Skill/MCP 提供领域工作流（如「发布前检查」= lint + test + build + 确认）。

### 11.2 撤销 / 回滚与操作账本

- **现状**：文档强调「可恢复」与审计，但未细化到「单步撤销」或「回滚到上一状态」。  
- **优化**：  
  - **操作账本**（operation ledger）：每次写盘或 UI 变更记录为一条（op_id, tool, args, result, timestamp, inverse?）；对支持逆操作的工具（如 edit、write、部分 ui_act）可记录 **inverse**（如「撤销该编辑」所需的参数或脚本）。  
  - **显式撤销**：提供 `undo_last` 或「回滚到 op_id」能力（仅对已记录 inverse 的操作生效），便于用户或模型在误操作后恢复。  
- **扩展方式**：在 `ToolResult` 或执行层约定可选字段 `undoHint?: { tool, args }`；审计日志与账本统一格式，便于后续做「回放」或「重做」。

### 11.3 预执行与干跑（dry-run / preview）

- **现状**：「提议与执行分离」覆盖「先提议再确认」，但未统一为「先返回将要执行的动作列表再执行」。  
- **优化**：  
  - **dry-run 模式**：对支持的工具（bash、edit、ui_act 等），可传入 `dryRun: true`；执行层返回「将要执行的内容」（如命令原文、将修改的文件与 diff 摘要、将点击的控件），**不实际执行**，供用户或策略确认后再发同参数不带 dryRun 的调用。  
  - **preview 与 diff**：对 write/edit 类操作，在返回结果中增强「变更摘要」（如受影响文件、行数、关键片段），便于确认与审计。  
- **扩展方式**：在 `ToolDef.inputSchema` 中为相关工具增加可选 `dryRun?: boolean`；handler 内分支处理，返回结构化 preview 而非执行。

### 11.4 批量化与事务性

- **现状**：多次 read/edit 或多次 bash 为多次独立调用，cwd 与环境按次可能不一致；多文件编辑无法「要么全成功要么全不写」。  
- **优化**：  
  - **批量文件操作**：单次工具调用支持「多文件」参数（如 `edit` 接受 `edits: [{ path, ... }]`），执行层顺序或并行执行并返回统一结果；可选「原子」语义：任一步失败则已执行的写操作回滚（若支持 undoHint）。  
  - **持久化 shell 会话**：bash 可选「复用同一 shell」（如保持 cwd、env、历史），减少重复 cd 与 export，便于多步脚本化任务。  
- **扩展方式**：扩展现有 `edit`/`write` 的 schema 支持数组；新增 `bash_session` 或为 bash 增加 `sessionId?: string` 以复用会话。

### 11.5 超时、取消与资源约束

- **现状**：长时间运行的 bash 或 ui 操作可能阻塞 Agent 轮次，且无统一取消入口。  
- **优化**：  
  - **每操作超时**：为 bash、process、ui_act 等配置最大执行时间（如 60s）；超时则中止并返回明确错误与 partial 输出（若有）。  
  - **可取消**：对长时操作返回 `operationId`；用户或 Heartbeat 可调用 `cancel(operationId)` 终止该次执行。  
  - **资源提示**：在工具描述或结果中可选标注「可能耗时」「将修改 N 个文件」等，供模型或用户决定是否确认、分批。  
- **扩展方式**：执行层（调用 handler 的框架）统一包装超时与 AbortSignal；Gateway 或终端暴露 `tools.cancel` 方法。

### 11.6 操作契约与可扩展性（Schema、版本、自定义操作）

- **现状**：`ToolDef` 已有 name、inputSchema、handler；新能力以新工具或 MCP 接入，但未显式约定「操作契约」的演进与兼容。  
- **优化**：  
  - **操作契约**：为工具或意图动作定义稳定 **operation contract**（输入/输出形状、错误码、是否可撤销、是否支持 dryRun），便于多版本 Gateway/终端兼容；新加字段采用可选向后兼容。  
  - **版本与弃用**：inputSchema 或工具元数据可带 `version`、`deprecated?: string`；调用方或 Prompt 可据此提示模型优先使用新工具。  
  - **自定义操作注册**：Skill/MCP 注册的新工具自动纳入同一套「能力路由、审计、可观测性」管道；意图级动作（如 9.3）可允许 Skill 注册新意图与解析规则，扩展「语义层」而不改核心执行器。  
- **扩展方式**：在 `ToolDef` 上增加可选 `version?`、`deprecated?`、`supportsDryRun?`、`supportsUndo?`；意图路由表可配置或由 MCP/Skill 扩展。

### 11.7 人机确认粒度与策略

- **现状**：敏感操作「需用户确认」为可选策略，但未细化到「按工具/按工作区/按危险模式」的粒度。  
- **优化**：  
  - **可配置确认策略**：按工具名（如所有 `ui_act`）、按工作区、按操作类型（如「包含 rm -rf 的 bash」「修改 .env 的 write」）配置为「始终确认 / 首次确认 / 不确认」。  
  - **危险模式与白名单**：对 bash 可维护危险命令模式（如 `rm -rf`、`chmod 777`）或路径白名单；命中时强制确认或拒绝。  
- **扩展方式**：配置层增加 `confirmPolicy: { tool?: string[], workspace?: string[], pattern?: string[] }`；执行前由统一策略层判断是否先返回「待确认」占位结果。

### 11.8 可重放与结构化审计

- **现状**：审计为「记录目标、动作、时间」，便于复盘。  
- **优化**：  
  - **结构化操作日志**：每条记录为 (op_id, tool, args, result, channel_used?, timestamp)，便于导出、查询与**重放**（replay）：在相同或另一 workspace 按序重放操作序列，用于复现问题或「再执行一遍」。  
  - **用户可见「再跑一次」**：终端或画布提供「重复上次命令/工作流」入口，基于上述结构化日志触发同参数调用。  
- **扩展方式**：审计存储采用统一 JSON 行或表结构；Gateway 暴露 `replay(ops: op_id[])` 或终端发等价 `tools.call` 序列。

### 11.9 异步与长时操作

- **现状**：工具调用多为同步「调用 → 等结果 → 返回」。  
- **优化**：  
  - **异步句柄**：对明确的长时操作（如「全量构建」「长时间测试」），执行层可返回 `asyncHandle`，立即返回；模型或用户通过 `get_operation_status(asyncHandle)` 轮询或由 Gateway 在完成后推送通知。  
  - **不阻塞会话**：同一会话可先发起异步操作，再继续其他对话或工具调用，最后再查状态或收结果。  
- **扩展方式**：部分工具（如 `bash` 或新的 `run_build`）在参数中支持 `async?: boolean`；返回 `{ asyncHandle, message }`；新增 `operation_status` 工具或 Gateway 方法。

### 11.10 与现有实现的衔接

- **ToolResult**：现有 `{ ok, content } | { ok: false, error, code?, suggestion? }` 可扩展为可选携带 `state_snapshot?`、`channel_used?`、`suggested_next?`、`undoHint?`、`asyncHandle?`，与第九、十节及本节约定一致，且保持向后兼容（旧 handler 不返回这些字段仍合法）。  
- **ToolDef**：新增可选元数据如 `supportsDryRun`、`supportsUndo`、`timeoutMs`、`version`，由合并层或执行层读取，不破坏现有 CORE_TOOLS / Skill / MCP 合并逻辑。  
- **执行顺序**：上述优化可与「意图路由、能力解析器、env_summary」叠加：先解析意图 → 再按策略做 dry-run/确认 → 再执行 → 写账本与审计 → 返回统一结果结构。

---

**小结**：在现有「分层、语义优先、可观测、意图路由」基础上，通过**复合操作与工作流、撤销/账本、dry-run、批量/事务、超时/取消、操作契约与扩展、确认策略、可重放审计、异步长时操作**以及**与 ToolDef/ToolResult 的衔接**，可进一步优化与扩展「操作与命令」的表达力、安全性与可维护性；实现时可按 Phase 分步采纳（如先 dry-run 与超时，再账本与撤销，再工作流与异步）。

---

*本文档为「智能助手可操作 IDE/PC」的能力探索与设计；具体实现以后续工单与 Phase 为准。*
