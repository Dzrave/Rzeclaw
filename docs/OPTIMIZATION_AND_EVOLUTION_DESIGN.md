# Rzeclaw 最小单元：优化与自我进化设计（回答与设计稿）

本文档针对「最小核心」阶段，回答：是否有进一步优化空间、能否更智能、是否适合引入自我进化/自我迭代机制；并给出**优先设计**，暂不涉及实现细节。

---

## 一、多轮会话效率优化

### 1.1 问题与目标

- **问题**：轮次越多，上下文越长，延迟与成本上升，且无关历史会干扰当前决策。
- **目标**：在保持「能看懂之前做了什么」的前提下，减少每轮输入的 token、加快响应、降低成本。

### 1.2 可优化方向（设计级）

| 方向 | 思路 | 与最小单元的契合度 |
|------|------|--------------------|
| **上下文裁剪/窗口** | 只保留最近 N 轮 + 首条用户目标摘要；中间轮用「摘要块」替代原文。 | 高：逻辑简单，不依赖新服务。 |
| **按轮摘要** | 每 N 轮或每轮结束时，用一次短 prompt 将「已做何事、当前状态、未完成目标」压成一段固定长度摘要，下一轮以「摘要 + 最近 1～2 轮原文」作为上下文。 | 高：仍只依赖现有 LLM + 单次调用。 |
| **分层上下文** | 将上下文分为「系统级摘要（目标/约束）」「会话摘要」「最近完整轮次」；模型侧若支持多段 system/context 可对应利用。 | 中：依赖模型/接口能力。 |
| **缓存与去重** | 对「重复文件内容、重复工具结果」做指纹或哈希，相同内容用占位符 + 缓存 id，避免同一大段内容多次进上下文。 | 中：需轻量存储与查找。 |
| **会话快照与恢复** | 定期将会话状态（摘要 + 最近轮 + 工具注册）序列化；恢复时从快照加载而非从空历史重建。 | 高：利于长会话与重启后「接着聊」。 |

**建议优先**：在最小单元阶段先做「按轮摘要 + 固定窗口最近轮」，再视需要加「会话快照」。这样在不引入新依赖的前提下，多轮效率提升最明显。

---

## 二、更快、更准确的工具调用

### 2.1 问题与目标

- **问题**：工具名/参数填错、多余调用、顺序不当、重复尝试，导致延迟高、结果不准。
- **目标**：减少无效调用、一次就传对参数、必要时合并或预判调用。

### 2.2 可优化方向（设计级）

| 方向 | 思路 | 与最小单元的契合度 |
|------|------|--------------------|
| **工具描述与示例** | 在 schema 外为每个工具写「何时用、典型用法、易错点」+ 1～2 个 JSON 示例；在 system 或 TOOLS 文档中注入，提升模型对工具的「一次选对」率。 | 高：仅改 prompt/配置。 |
| **参数校验与反馈** | 工具执行前做轻量校验（路径是否越界、必填是否缺失、类型是否合理）；失败时返回**结构化错误码 + 修正建议**（如 "PATH_OUTSIDE_WORKSPACE: 请使用相对 workspace 的路径"），便于模型下一轮自我修正。 | 高：在现有 handler 外裹一层即可。 |
| **工具结果压缩** | 对 `bash`/`read` 等长输出做「截断 + 尾部保留 + 行数/字数说明」，或对超大文件只返回首尾 + 行数，减少无效 token。 | 高：纯后处理。 |
| **意图→工具映射提示** | 在 system 中加简短「意图→推荐工具」表（如「改文件某处」→ edit；「执行命令」→ bash；「看文件」→ read），降低误选工具概率。 | 高：仅改 prompt。 |
| **并行/批量工具** | 若模型支持一次返回多个 tool_use，服务端并行执行并合并结果再回传，减少往返轮数。 | 中：依赖模型与协议。 |
| **工具调用历史摘要** | 在上下文中不保留每轮完整 tool_use/tool_result，而是「本会话已用过的工具及最后一次结果摘要」，避免重复信息占满上下文。 | 高：与多轮摘要结合。 |

**建议优先**：工具描述+示例、参数校验+结构化错误、工具结果压缩、意图→工具提示。这几项在最小单元内即可做，且对「更快更准」直接见效。

---

## 三、整体上「更智能」的行为

### 3.1 问题与目标

- **问题**：仅「问一句答一句 + 工具调用」容易变成被动执行，缺乏规划、反思和纠错。
- **目标**：在不大幅增加复杂度的前提下，让助手更会规划、反思和从失败中恢复。

### 3.2 可优化方向（设计级）

| 方向 | 思路 | 与最小单元的契合度 |
|------|------|--------------------|
| **轻量规划** | 对复杂请求（多步、多文件、多命令），先让模型输出「步骤列表」或「计划块」（不执行），再按步执行并每步后更新「已完成/未完成」；可约束为「最多 N 步」避免发散。 | 高：通过 system 指令 + 可选的一轮「只规划不执行」即可。 |
| **执行后反思** | 关键步骤后（如 write/edit/bash 执行完），在 system 或 user 中加一句「请根据上一步结果判断：是否达成子目标、是否需要重试或换策略」。可做成「每 K 次工具调用后插入一次反思提示」。 | 高：仅改 prompt 与插入逻辑。 |
| **错误恢复策略** | 当工具返回错误时，不仅返回错误信息，还附带「建议」（如 permission_denied → 「可尝试检查路径权限或换路径」）；模型据此自动重试或换方案。 | 高：与 2.2 参数校验与反馈一致。 |
| **用户偏好记忆** | 在会话或用户维度存「偏好」（如默认用哪个 shell、常用目录、不执行哪类命令）；在 system 中注入「当前用户偏好」，使回复更贴合习惯。 | 中：需极简存储（如单 JSON 文件）。 |
| **目标锚定** | 每轮开始时在上下文显式保留「用户本轮/本会话的主要目标」；长对话中定期重申该目标，减少跑题与无效工具调用。 | 高：与摘要结合即可。 |

**建议优先**：轻量规划（可选）、执行后反思（每若干次工具调用插入）、错误恢复建议、目标锚定。这些都不依赖新基础设施，只在 prompt 与流程上做文章。

---

## 四、自我进化与自我迭代机制（是否适合在本阶段引入）

### 4.1 概念边界

- **自我进化/自我迭代**：系统能根据自身运行结果（成功/失败、用户反馈、指标）**自动或半自动地**调整自己的行为、策略或知识，使后续表现更好。
- **最小单元**：无外部反馈闭环、无复杂基础设施，仅单机、单会话、本地工具。

### 4.2 结论（优先回答）

- **可以、且适合在最小单元阶段引入「轻量级」的自我迭代机制**，但应严格限定在「可观测、可记录、可被后续会话或人工利用」的范围内，避免复杂度和不可控风险。
- **不适合**在本阶段做：全自动改写系统 prompt、自动安装/执行任意代码、自动变更工具实现等「强自主」行为；这些更适合在有了权限与安全边界（如沙箱、审核、人机协同）后再考虑。

### 4.3 可在本阶段设计的「自我进化/迭代」机制

| 机制 | 含义 | 实现复杂度 | 风险 |
|------|------|------------|------|
| **运行日志与可观测性** | 结构化记录：每轮用户消息、模型输出、工具调用及结果、耗时、token 数。不自动改行为，只为「事后分析与迭代」提供数据。 | 低 | 低 |
| **会话内自纠错** | 工具失败时，由模型根据**结构化错误与建议**自动重试或换策略（见 2.2、3.2）；可视为「单会话内的自我修正」，不跨会话。 | 低 | 低 |
| **会话级「学到了什么」** | 在会话结束时（或每 N 轮），让模型输出一段「本会话总结：做了哪些操作、遇到什么问题、如何解决的」。写入本地文件或会话日志，供后续会话或人工参考，**不自动写回 system/配置**。 | 低 | 低 |
| **轻量指标与统计** | 统计每会话：工具调用次数、失败率、重试次数、总 token。用于判断「哪里最常出错、哪种工具最费 token」，为**人工**优化 prompt/工具设计提供依据。 | 低 | 低 |
| **Bootstrap / 自举文档** | 维护一份「Rzeclaw 使用与最佳实践」文档（如 `WORKSPACE_BEST_PRACTICES.md`），可选：在会话中允许模型**只读**该文档，或允许在用户确认后**追加**「本次会话的一条经验」到文档末尾。进化主体是「文档内容」，不是代码或配置。 | 中 | 中（需用户确认或只读） |
| **可选：模型对自身 prompt 的「建议」** | 会话结束或定期，让模型输出「若改进 system/工具描述，建议增加或修改以下内容」的文本，**仅保存为建议文件，不自动应用**。由人在下次发布时决定是否采纳。 | 中 | 低 |

### 4.4 不建议在本阶段做的「强自我进化」

- **自动修改 system prompt 或工具 schema**：容易漂移、难以审计，且与「最小可控」冲突。
- **自动安装/拉取新工具或插件**：涉及安全与依赖管理，应单独成阶段。
- **跨会话自动学习用户习惯并写回配置**：除非有明确用户确认与回滚机制，否则不建议在最小单元默认开启。

### 4.5 建议的「自我进化」优先级（设计顺序）

1. **运行日志 + 轻量指标**：先能观测，再谈优化。
2. **会话内自纠错**：利用结构化错误与建议，减少同一错误的重复发生。
3. **会话总结 / 「本会话学到了什么」**：输出到文件，供后续或人工使用，不自动回写。
4. **可选的 Bootstrap 文档（只读或需确认的追加）**：让「经验」以文档形式积累。
5. **模型对 prompt 的改进建议（仅写入建议文件）**：为人驱的迭代提供输入。

---

## 五、综合优先级（便于后续实现时选型）

- **多轮效率**：按轮摘要 + 最近轮窗口；可选会话快照。
- **工具调用**：工具描述+示例、参数校验+结构化错误、结果压缩、意图→工具提示。
- **更智能**：目标锚定、执行后反思、错误恢复建议；可选轻量规划。
- **自我进化**：运行日志与轻量指标 → 会话内自纠错 → 会话总结/「学到了什么」→ 可选 Bootstrap 文档与 prompt 建议文件。

以上均为**回答与设计**，具体实现可在你确认优先级后再拆成任务逐步落地。
